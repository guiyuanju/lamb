let 0 = \f.\x.x in
let succ = \n.\f.\x.f (n f x) in
let pred = \n.\f.\x.n (\g.\h.h (g f)) (\u.x) (\u.u) in
let + = \m.\n.\f.\x.m f (n f x) in
let - = \m.\n.n pred m in
let * = \m.\n.m (+ n) 0 in
let pow = \b.\n.n b in
let true = \x.\y.x in
let false = \x.\y.y in
let and = \p.\q.p q p in
let or = \p.\q.p p q in
let not = \p.p false true in
let if_then_else = \p.\a.\b.p a b in
let is_zero = \n.n (\x.false) true in
let <= = \m.\n.is_zero (- m n) in
let 1 = succ 0 in
let 2 = succ 1 in
let 3 = succ 2 in
let 4 = succ 3 in
let Y = \g.(\x.g (x x)) (\x.g (x x)) in
let Z = \g.(\x.g (\v. x x v)) (\x.g (\v. x x v)) in
let G = \r.\n.(if_then_else (is_zero n) 1 (* n (r (- n 1)))) in
